<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Tablix: data.c File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.2 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    <li class="current"><a href="files.html"><span>Files</span></a></li>
  </ul>
</div>
<div class="tabs">
  <ul>
    <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    <li><a href="globals.html"><span>Globals</span></a></li>
  </ul>
</div>
<h1>data.c File Reference</h1>Static data storage (resources). <a href="#_details">More...</a>
<p>
<code>#include &lt;stdio.h&gt;</code><br>
<code>#include &lt;stdlib.h&gt;</code><br>
<code>#include &lt;string.h&gt;</code><br>
<code>#include &lt;dlfcn.h&gt;</code><br>
<code>#include &quot;main.h&quot;</code><br>
<code>#include &quot;<a class="el" href="data_8h.html">data.h</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="modsup_8h.html">modsup.h</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="error_8h.html">error.h</a>&quot;</code><br>
<code>#include &quot;gettext.h&quot;</code><br>
<code>#include &quot;assert.h&quot;</code><br>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structdomain__t.html">domain</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="data_8c.html#29ab9b1967c0d5cb69a5fdb8194e7a01">domain_new</a> (<a class="el" href="structresourcetype__t.html">resourcetype</a> *restype)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a new full domain. (domain with all possible values for a specified resource type).  <a href="#29ab9b1967c0d5cb69a5fdb8194e7a01"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="data_8c.html#dbea669ee75cab76868e1347478f99f8">domain_addtuple</a> (<a class="el" href="structdomain__t.html">domain</a> *dom, <a class="el" href="structtupleinfo__t.html">tupleinfo</a> *tuple)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a tuple to a domain.  <a href="#dbea669ee75cab76868e1347478f99f8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="data_8c.html#391a1b4d52d787ee5e4668c331320816">domain_and</a> (<a class="el" href="structdomain__t.html">domain</a> *dom, int *val, int valnum)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes some values from a domain.  <a href="#391a1b4d52d787ee5e4668c331320816"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="data_8c.html#c8f74dd0d4caa58c6c7e12b8901c6f6f">domain_free</a> (<a class="el" href="structdomain__t.html">domain</a> *dom)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free a domain structure.  <a href="#c8f74dd0d4caa58c6c7e12b8901c6f6f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f01a5e4063bdb0c5b8afd457331285ee"></a><!-- doxytag: member="data.c::domain_freeall" ref="f01a5e4063bdb0c5b8afd457331285ee" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="data_8c.html#f01a5e4063bdb0c5b8afd457331285ee">domain_freeall</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free all domains. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="data_8c.html#e301981d7f287faa0e536ad9acf3ba59">domain_compare</a> (<a class="el" href="structdomain__t.html">domain</a> *d1, <a class="el" href="structdomain__t.html">domain</a> *d2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compare if two domains contain same values.  <a href="#e301981d7f287faa0e536ad9acf3ba59"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="data_8c.html#8feab1543bd876445e2895e89d16a104">compact_domains</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Finds and merges duplicate domains.  <a href="#8feab1543bd876445e2895e89d16a104"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="data_8c.html#7f75aaadee4f1c355b267375ea84ef6c">domain_rand</a> (<a class="el" href="structdomain__t.html">domain</a> *dom)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a random value from a domain.  <a href="#7f75aaadee4f1c355b267375ea84ef6c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="data_8c.html#de84ca9ca11ab4fda59862e923ff7f8a">domain_check</a> (<a class="el" href="structdomain__t.html">domain</a> *dom, int val)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks if a value is present in a domain.  <a href="#de84ca9ca11ab4fda59862e923ff7f8a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structresourcetype__t.html">resourcetype</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="data_8c.html#8c72b98be13cab05b381a8a78f6efabb">restype_new</a> (int var, char *type)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Define a new resource type.  <a href="#8c72b98be13cab05b381a8a78f6efabb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="data_8c.html#bbfc9bd4c1cb4fc9e9c454823c0b011d">restype_findid</a> (char *type)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find a resource type (either variable or constant) by name and return a resource type ID.  <a href="#bbfc9bd4c1cb4fc9e9c454823c0b011d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structresourcetype__t.html">resourcetype</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="data_8c.html#a86e740a213a28a01fcae6023a3f7c88">restype_find</a> (char *type)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find a resource type by name.  <a href="#a86e740a213a28a01fcae6023a3f7c88"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="data_8c.html#db3b01d97e46671cf4a05b1ac5590ce3">res_set_conflict</a> (<a class="el" href="structresource__t.html">resource</a> *res1, <a class="el" href="structresource__t.html">resource</a> *res2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set conflict between resource <em>res1</em> and resource <em>res2</em>.  <a href="#db3b01d97e46671cf4a05b1ac5590ce3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="data_8c.html#0c171834812b4d14775623985fd79b04">compact_conflicts</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generates conflict lookup tables for all defined resource types.  <a href="#0c171834812b4d14775623985fd79b04"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structresource__t.html">resource</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="data_8c.html#ef5a6cb806d689cc5b76627abb5c2166">res_new</a> (<a class="el" href="structresourcetype__t.html">resourcetype</a> *restype, char *name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a new resource to a resource type.  <a href="#ef5a6cb806d689cc5b76627abb5c2166"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structresource__t.html">resource</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="data_8c.html#18de03225d8f767f115c850d8d2a85fc">res_new_matrix</a> (<a class="el" href="structresourcetype__t.html">resourcetype</a> *restype, int width, int height)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a matrix of resources to a resource type.  <a href="#18de03225d8f767f115c850d8d2a85fc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="data_8c.html#162d1f026f08a407a97a57e12f5a084b">res_get_matrix</a> (<a class="el" href="structresourcetype__t.html">resourcetype</a> *restype, int *width, int *height)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Finds the dimensions of a matrix of resources.  <a href="#162d1f026f08a407a97a57e12f5a084b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="data_8c.html#5bb5a03151639293a7e58a8075857109">res_findid</a> (<a class="el" href="structresourcetype__t.html">resourcetype</a> *restype, char *name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find a resource by name and return its resource ID.  <a href="#5bb5a03151639293a7e58a8075857109"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structresource__t.html">resource</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="data_8c.html#f8ee458d05e7025de8346537ebf9545e">res_find</a> (<a class="el" href="structresourcetype__t.html">resourcetype</a> *restype, char *name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find a resource by name.  <a href="#f8ee458d05e7025de8346537ebf9545e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="bf0f0f2c79b003831fa11843b1290f15"></a><!-- doxytag: member="data.c::restype_freeall" ref="bf0f0f2c79b003831fa11843b1290f15" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="data_8c.html#bf0f0f2c79b003831fa11843b1290f15">restype_freeall</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free all resource types and all resources. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="data_8c.html#bf094f2f8d7a6ad2fed40fd15580d5cb">tuple_set</a> (<a class="el" href="structtupleinfo__t.html">tupleinfo</a> *tuple, <a class="el" href="structresource__t.html">resource</a> *res)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set a resource in a tuple.  <a href="#bf094f2f8d7a6ad2fed40fd15580d5cb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="data_8c.html#36f9004d242d4b2e2fec8775a520aad8">tuple_compare</a> (int tupleid1, int tupleid2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compare two events.  <a href="#36f9004d242d4b2e2fec8775a520aad8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structtupleinfo__t.html">tupleinfo</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="data_8c.html#44052420d49f2b5f148b523ed2f8c96d">tuple_new</a> (char *name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a new tuple.  <a href="#44052420d49f2b5f148b523ed2f8c96d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d5b38030a906ea21211e2d7d35bd8792"></a><!-- doxytag: member="data.c::tuple_freeall" ref="d5b38030a906ea21211e2d7d35bd8792" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="data_8c.html#d5b38030a906ea21211e2d7d35bd8792">tuple_freeall</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free all tuples. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structtuplelist__t.html">tuplelist</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="data_8c.html#c6fb99fb15e66709254a1a2dc077a02b">tuplelist_new</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate a new empty tuplelist structure.  <a href="#c6fb99fb15e66709254a1a2dc077a02b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="data_8c.html#6c1b05d7745473756e5fd19e695453ed">tuplelist_add</a> (<a class="el" href="structtuplelist__t.html">tuplelist</a> *dest, int tupleid)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a new tupleid to the tuplelist structure.  <a href="#6c1b05d7745473756e5fd19e695453ed"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="data_8c.html#446a7351d03c08874dd0e9e2f9128103">tuplelist_free</a> (<a class="el" href="structtuplelist__t.html">tuplelist</a> *dest)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Frees a tuplelist structure.  <a href="#446a7351d03c08874dd0e9e2f9128103"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structoutputext__t.html">outputext</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="data_8c.html#8f376e95d654b3961915cbd6758880d4">outputext_new</a> (char *contype, char *vartype)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate a new output extension struct.  <a href="#8f376e95d654b3961915cbd6758880d4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="data_8c.html#a2e857965f07b8ff04a1dbbb454a00fe">outputext_update</a> (<a class="el" href="structoutputext__t.html">outputext</a> *ex, <a class="el" href="structtable__t.html">table</a> *tab)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Update output extension with new data from a timetable.  <a href="#a2e857965f07b8ff04a1dbbb454a00fe"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="data_8c.html#25641e5973957b3b2750aa7a540145c2">outputext_free</a> (<a class="el" href="structoutputext__t.html">outputext</a> *dest)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free an output extension struct.  <a href="#25641e5973957b3b2750aa7a540145c2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structext__t.html">ext</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="data_8c.html#9f7642e6e1f4fc3ea34c0af73044ea98">ext_new</a> (<a class="el" href="structext__t.html">ext</a> **ex, int contype, int vartype)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate a new extension struct in a linked list.  <a href="#9f7642e6e1f4fc3ea34c0af73044ea98"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="data_8c.html#a20858ca8009740dbce83b18f7ae0bad">ext_update</a> (<a class="el" href="structext__t.html">ext</a> *ex, <a class="el" href="structtable__t.html">table</a> *tab)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Update extension with new data from a timetable.  <a href="#a20858ca8009740dbce83b18f7ae0bad"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structslist__t.html">slist</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="data_8c.html#8e0215f87e5f9bb04e91d481c10c9e76">slist_new</a> (<a class="el" href="structslist__t.html">slist</a> **list, int vartype)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate a new slist struct in a linked list.  <a href="#8e0215f87e5f9bb04e91d481c10c9e76"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="data_8c.html#ee56fd95809a035700e03c72671890c4">slist_update</a> (<a class="el" href="structslist__t.html">slist</a> *list, <a class="el" href="structtable__t.html">table</a> *tab)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Update slist with new data from a timetable.  <a href="#ee56fd95809a035700e03c72671890c4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="data_8c.html#5269004def0ddb80851929445699c1d0">data_init</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prepare data structures for use.  <a href="#5269004def0ddb80851929445699c1d0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2f0b042d6505506882482add2899a211"></a><!-- doxytag: member="data.c::data_exit" ref="2f0b042d6505506882482add2899a211" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="data_8c.html#2f0b042d6505506882482add2899a211">data_exit</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free all memory allocated by <a class="el" href="data_8c.html#8c72b98be13cab05b381a8a78f6efabb" title="Define a new resource type.">restype_new()</a>, <a class="el" href="data_8c.html#ef5a6cb806d689cc5b76627abb5c2166" title="Add a new resource to a resource type.">res_new()</a>, <a class="el" href="data_8c.html#29ab9b1967c0d5cb69a5fdb8194e7a01" title="Creates a new full domain. (domain with all possible values for a specified resource...">domain_new()</a> and <a class="el" href="data_8c.html#44052420d49f2b5f148b523ed2f8c96d" title="Add a new tuple.">tuple_new()</a>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="8c26d5399a635c6ce242244a0f83f4f4"></a><!-- doxytag: member="data.c::table_init" ref="8c26d5399a635c6ce242244a0f83f4f4" args="(table *tab, int new)" -->
static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="data_8c.html#8c26d5399a635c6ce242244a0f83f4f4">table_init</a> (<a class="el" href="structtable__t.html">table</a> *tab, int new)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper function for <a class="el" href="data_8c.html#a9d4ac95746ba0bbec45b62fa07f4873" title="Initializes population structure.">population_init()</a>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structpopulation__t.html">population</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="data_8c.html#a9d4ac95746ba0bbec45b62fa07f4873">population_init</a> (<a class="el" href="structpopulation__t.html">population</a> *pop, int size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initializes population structure.  <a href="#a9d4ac95746ba0bbec45b62fa07f4873"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="data_8c.html#04c8cd2d65196bd73cf6baef3f8fe838">population_rand</a> (<a class="el" href="structpopulation__t.html">population</a> *pop)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Randomize the entire population.  <a href="#04c8cd2d65196bd73cf6baef3f8fe838"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="86f8a8813e5b3e0cbe19e36354b181ac"></a><!-- doxytag: member="data.c::table_hint" ref="86f8a8813e5b3e0cbe19e36354b181ac" args="(table *tab, int typeid)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>table_hint</b> (<a class="el" href="structtable__t.html">table</a> *tab, int typeid)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="data_8c.html#27dcfc1874a3ef11492135b67264ca08">population_hint</a> (<a class="el" href="structpopulation__t.html">population</a> *pop, int hintpart)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Hint a part of the population.  <a href="#27dcfc1874a3ef11492135b67264ca08"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d9ae5562e0b30e53221c64a69caee7a8"></a><!-- doxytag: member="data.c::dat_info" ref="d9ae5562e0b30e53221c64a69caee7a8" args="" -->
<a class="el" href="structmiscinfo__t.html">miscinfo</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="data_8c.html#d9ae5562e0b30e53221c64a69caee7a8">dat_info</a> = { title: NULL, address: NULL, author: NULL }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Miscellaneous information about the timetable. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c3188ab7211e4976c8cdd11a06c7f7b3"></a><!-- doxytag: member="data.c::dat_typenum" ref="c3188ab7211e4976c8cdd11a06c7f7b3" args="" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="data_8c.html#c3188ab7211e4976c8cdd11a06c7f7b3">dat_typenum</a> = 0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Number of all defined resource types. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="baecf61957ea9a4b5fb1927822ee662a"></a><!-- doxytag: member="data.c::dat_restype" ref="baecf61957ea9a4b5fb1927822ee662a" args="" -->
<a class="el" href="structresourcetype__t.html">resourcetype</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="data_8c.html#baecf61957ea9a4b5fb1927822ee662a">dat_restype</a> = NULL</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Array of <em>dat_typenum</em> resource types. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="caf4102dbb48665b4d5122de27db8ffd"></a><!-- doxytag: member="data.c::dat_tuplenum" ref="caf4102dbb48665b4d5122de27db8ffd" args="" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="data_8c.html#caf4102dbb48665b4d5122de27db8ffd">dat_tuplenum</a> = 0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Number of all defined tuples (events). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c2bca7141cd721c6815db0d0d8ddf802"></a><!-- doxytag: member="data.c::dat_tuplemap" ref="c2bca7141cd721c6815db0d0d8ddf802" args="" -->
<a class="el" href="structtupleinfo__t.html">tupleinfo</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="data_8c.html#c2bca7141cd721c6815db0d0d8ddf802">dat_tuplemap</a> = NULL</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Array of <em>dat_tuplenum</em> tuples. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1592ff0ebd5ae96777657275fd267890"></a><!-- doxytag: member="data.c::dat_domains" ref="1592ff0ebd5ae96777657275fd267890" args="" -->
<a class="el" href="structdomain__t.html">domain</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="data_8c.html#1592ff0ebd5ae96777657275fd267890">dat_domains</a> = NULL</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Linked list of defined domains. <br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Static data storage (resources). 
<p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="0c171834812b4d14775623985fd79b04"></a><!-- doxytag: member="data.c::compact_conflicts" ref="0c171834812b4d14775623985fd79b04" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int compact_conflicts           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Generates conflict lookup tables for all defined resource types. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success and -1 on error. </dd></dl>

</div>
</div><p>
<a class="anchor" name="8feab1543bd876445e2895e89d16a104"></a><!-- doxytag: member="data.c::compact_domains" ref="8feab1543bd876445e2895e89d16a104" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int compact_domains           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Finds and merges duplicate domains. 
<p>
This function must be called after all tuples were added. <dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success and -1 on error. </dd></dl>

</div>
</div><p>
<a class="anchor" name="5269004def0ddb80851929445699c1d0"></a><!-- doxytag: member="data.c::data_init" ref="5269004def0ddb80851929445699c1d0" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int data_init           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Prepare data structures for use. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success and -1 on error. </dd></dl>

</div>
</div><p>
<a class="anchor" name="dbea669ee75cab76868e1347478f99f8"></a><!-- doxytag: member="data.c::domain_addtuple" ref="dbea669ee75cab76868e1347478f99f8" args="(domain *dom, tupleinfo *tuple)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int domain_addtuple           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdomain__t.html">domain</a> *&nbsp;</td>
          <td class="paramname"> <em>dom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtupleinfo__t.html">tupleinfo</a> *&nbsp;</td>
          <td class="paramname"> <em>tuple</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds a tuple to a domain. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dom</em>&nbsp;</td><td>Pointer to the domain struct. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tuple</em>&nbsp;</td><td>Pointer to the tupleinfo struct. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success or -1 on error. </dd></dl>

</div>
</div><p>
<a class="anchor" name="391a1b4d52d787ee5e4668c331320816"></a><!-- doxytag: member="data.c::domain_and" ref="391a1b4d52d787ee5e4668c331320816" args="(domain *dom, int *val, int valnum)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void domain_and           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdomain__t.html">domain</a> *&nbsp;</td>
          <td class="paramname"> <em>dom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>valnum</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes some values from a domain. 
<p>
This function removes all values from <em>dom</em> domain that are not in the <em>val</em> list.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dom</em>&nbsp;</td><td>Pointer to the domain struct </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td>Array of values </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>valnum</em>&nbsp;</td><td>Number of values in the array </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="de84ca9ca11ab4fda59862e923ff7f8a"></a><!-- doxytag: member="data.c::domain_check" ref="de84ca9ca11ab4fda59862e923ff7f8a" args="(domain *dom, int val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int domain_check           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdomain__t.html">domain</a> *&nbsp;</td>
          <td class="paramname"> <em>dom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Checks if a value is present in a domain. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dom</em>&nbsp;</td><td>Pointer to the domain struct. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td>Value to be checked for. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>1 if the value is present in a domain or 0 if the value is not present. </dd></dl>

</div>
</div><p>
<a class="anchor" name="e301981d7f287faa0e536ad9acf3ba59"></a><!-- doxytag: member="data.c::domain_compare" ref="e301981d7f287faa0e536ad9acf3ba59" args="(domain *d1, domain *d2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int domain_compare           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdomain__t.html">domain</a> *&nbsp;</td>
          <td class="paramname"> <em>d1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdomain__t.html">domain</a> *&nbsp;</td>
          <td class="paramname"> <em>d2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compare if two domains contain same values. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>d1</em>&nbsp;</td><td>Pointer to the first domain </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>d2</em>&nbsp;</td><td>Pointer to the second domain </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>1 if domains are equal or 0 if they are not </dd></dl>

</div>
</div><p>
<a class="anchor" name="c8f74dd0d4caa58c6c7e12b8901c6f6f"></a><!-- doxytag: member="data.c::domain_free" ref="c8f74dd0d4caa58c6c7e12b8901c6f6f" args="(domain *dom)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void domain_free           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdomain__t.html">domain</a> *&nbsp;</td>
          <td class="paramname"> <em>dom</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Free a domain structure. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dom</em>&nbsp;</td><td>Pointer to the domain struct to be freed </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="29ab9b1967c0d5cb69a5fdb8194e7a01"></a><!-- doxytag: member="data.c::domain_new" ref="29ab9b1967c0d5cb69a5fdb8194e7a01" args="(resourcetype *restype)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdomain__t.html">domain</a>* domain_new           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structresourcetype__t.html">resourcetype</a> *&nbsp;</td>
          <td class="paramname"> <em>restype</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a new full domain. (domain with all possible values for a specified resource type). 
<p>
The allocated domain contains no tuples.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>restype</em>&nbsp;</td><td>Resource type for this domain. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Pointer to the created domain struct or NULL on error. </dd></dl>

</div>
</div><p>
<a class="anchor" name="7f75aaadee4f1c355b267375ea84ef6c"></a><!-- doxytag: member="data.c::domain_rand" ref="7f75aaadee4f1c355b267375ea84ef6c" args="(domain *dom)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int domain_rand           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdomain__t.html">domain</a> *&nbsp;</td>
          <td class="paramname"> <em>dom</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a random value from a domain. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dom</em>&nbsp;</td><td>Pointer to the domain struct. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Random value from the domain. </dd></dl>

</div>
</div><p>
<a class="anchor" name="9f7642e6e1f4fc3ea34c0af73044ea98"></a><!-- doxytag: member="data.c::ext_new" ref="9f7642e6e1f4fc3ea34c0af73044ea98" args="(ext **ex, int contype, int vartype)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structext__t.html">ext</a>* ext_new           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structext__t.html">ext</a> **&nbsp;</td>
          <td class="paramname"> <em>ex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>contype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>vartype</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Allocate a new extension struct in a linked list. 
<p>
Linked list is first searched for an identical extension struct. If such a structure is found, only a pointer to it is returned and the linked is is not changed. If no such structure exists, a new structure is allocated and inserted at the beginning of the linked list.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ex</em>&nbsp;</td><td>Pointer to the linked list. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>contype</em>&nbsp;</td><td>Constant resource type id. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vartype</em>&nbsp;</td><td>Variable resource type id. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Pointer to the new extension struct or NULL on error. </dd></dl>

</div>
</div><p>
<a class="anchor" name="a20858ca8009740dbce83b18f7ae0bad"></a><!-- doxytag: member="data.c::ext_update" ref="a20858ca8009740dbce83b18f7ae0bad" args="(ext *ex, table *tab)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ext_update           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structext__t.html">ext</a> *&nbsp;</td>
          <td class="paramname"> <em>ex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtable__t.html">table</a> *&nbsp;</td>
          <td class="paramname"> <em>tab</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Update extension with new data from a timetable. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ex</em>&nbsp;</td><td>Pointer to the extension structure to update. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tab</em>&nbsp;</td><td>Pointer to the table with the new data. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="25641e5973957b3b2750aa7a540145c2"></a><!-- doxytag: member="data.c::outputext_free" ref="25641e5973957b3b2750aa7a540145c2" args="(outputext *dest)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void outputext_free           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structoutputext__t.html">outputext</a> *&nbsp;</td>
          <td class="paramname"> <em>dest</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Free an output extension struct. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>Pointer to the output extenstion struct to free. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="8f376e95d654b3961915cbd6758880d4"></a><!-- doxytag: member="data.c::outputext_new" ref="8f376e95d654b3961915cbd6758880d4" args="(char *contype, char *vartype)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoutputext__t.html">outputext</a>* outputext_new           </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>contype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>vartype</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Allocate a new output extension struct. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>contype</em>&nbsp;</td><td>Constant resource type. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vartype</em>&nbsp;</td><td>Variable resource type. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Pointer to the new output extension struct or NULL on error. </dd></dl>

</div>
</div><p>
<a class="anchor" name="a2e857965f07b8ff04a1dbbb454a00fe"></a><!-- doxytag: member="data.c::outputext_update" ref="a2e857965f07b8ff04a1dbbb454a00fe" args="(outputext *ex, table *tab)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int outputext_update           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structoutputext__t.html">outputext</a> *&nbsp;</td>
          <td class="paramname"> <em>ex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtable__t.html">table</a> *&nbsp;</td>
          <td class="paramname"> <em>tab</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Update output extension with new data from a timetable. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ex</em>&nbsp;</td><td>Pointer to the output extension structure to update. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tab</em>&nbsp;</td><td>Pointer to the table with the new data. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success and -1 on error. </dd></dl>

</div>
</div><p>
<a class="anchor" name="27dcfc1874a3ef11492135b67264ca08"></a><!-- doxytag: member="data.c::population_hint" ref="27dcfc1874a3ef11492135b67264ca08" args="(population *pop, int hintpart)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void population_hint           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpopulation__t.html">population</a> *&nbsp;</td>
          <td class="paramname"> <em>pop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>hintpart</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Hint a part of the population. 
<p>
If dat_tuplemap contains information that can be used to initialize variable chromosomes in the population (i.e. the user has loaded an XML file that already contains a partial or a full solution), then this function initializes some variable chromosomes.<p>
If dat_tuplemap doesn't contain this information this function does nothing.<p>
If the information in dat_tuplemap conflicts with a domain of a tuple then the dat_tuplemap information is ignored for that tuple and an error is reported.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pop</em>&nbsp;</td><td>Pointer to the population to be hinted. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hintpart</em>&nbsp;</td><td>Percent of the population that will be hinted. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="a9d4ac95746ba0bbec45b62fa07f4873"></a><!-- doxytag: member="data.c::population_init" ref="a9d4ac95746ba0bbec45b62fa07f4873" args="(population *pop, int size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpopulation__t.html">population</a>* population_init           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpopulation__t.html">population</a> *&nbsp;</td>
          <td class="paramname"> <em>pop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initializes population structure. 
<p>
All resources, resource types and tuples (events) must be defined before calling this function.<p>
If <em>pop</em> is NULL, a new structure with population size <em>size</em> is allocated using the number of tuples and resource types. If <em>pop</em> is not NULL then only proper links to resources, etc. are made.<p>
Checks are also performed to see if population <em>pop</em> is compatible with the number of defined resource types, etc. <em>size</em> parameter is not used in this case.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pop</em>&nbsp;</td><td>Pointer to the population structure to be initialized. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Size of the population. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Pointer to the initialized structure on success and NULL on error. </dd></dl>

</div>
</div><p>
<a class="anchor" name="04c8cd2d65196bd73cf6baef3f8fe838"></a><!-- doxytag: member="data.c::population_rand" ref="04c8cd2d65196bd73cf6baef3f8fe838" args="(population *pop)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void population_rand           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpopulation__t.html">population</a> *&nbsp;</td>
          <td class="paramname"> <em>pop</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Randomize the entire population. 
<p>
All variable chromosomes in the population are filled with random values (domains of individual tuples, as specified in <em>dat_tuplemap</em> are respected)<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pop</em>&nbsp;</td><td>Pointer to the population to be randomized. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="f8ee458d05e7025de8346537ebf9545e"></a><!-- doxytag: member="data.c::res_find" ref="f8ee458d05e7025de8346537ebf9545e" args="(resourcetype *restype, char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structresource__t.html">resource</a>* res_find           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structresourcetype__t.html">resourcetype</a> *&nbsp;</td>
          <td class="paramname"> <em>restype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Find a resource by name. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>restype</em>&nbsp;</td><td>Pointer to the resource type structure in which to search for the resource. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>Name of the resource type to find. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Pointer to the resource structure or NULL if this resource was not found. </dd></dl>

</div>
</div><p>
<a class="anchor" name="5bb5a03151639293a7e58a8075857109"></a><!-- doxytag: member="data.c::res_findid" ref="5bb5a03151639293a7e58a8075857109" args="(resourcetype *restype, char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int res_findid           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structresourcetype__t.html">resourcetype</a> *&nbsp;</td>
          <td class="paramname"> <em>restype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Find a resource by name and return its resource ID. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>restype</em>&nbsp;</td><td>Pointer to the resource type structure in which to search for the resource. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>Name of the resource type to find. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Resource ID or INT_MIN if this resource was not found. </dd></dl>

</div>
</div><p>
<a class="anchor" name="162d1f026f08a407a97a57e12f5a084b"></a><!-- doxytag: member="data.c::res_get_matrix" ref="162d1f026f08a407a97a57e12f5a084b" args="(resourcetype *restype, int *width, int *height)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int res_get_matrix           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structresourcetype__t.html">resourcetype</a> *&nbsp;</td>
          <td class="paramname"> <em>restype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>height</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Finds the dimensions of a matrix of resources. 
<p>
This function finds the width and height of a matrix of resources that was defined by the <a class="el" href="data_8c.html#18de03225d8f767f115c850d8d2a85fc" title="Adds a matrix of resources to a resource type.">res_new_matrix()</a> function. There must be no other resources defined in the specified resource type.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>restype</em>&nbsp;</td><td>Pointer to the resource type structure. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>width</em>&nbsp;</td><td>Width of the matrix. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>height</em>&nbsp;</td><td>Height of the matrix. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success (<em>width</em> and <em>height</em> are set to correct values) and -1 on error (this resource type does not contain a matrix of resources - <em>width</em> and <em>height</em> are not touched. </dd></dl>

</div>
</div><p>
<a class="anchor" name="ef5a6cb806d689cc5b76627abb5c2166"></a><!-- doxytag: member="data.c::res_new" ref="ef5a6cb806d689cc5b76627abb5c2166" args="(resourcetype *restype, char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structresource__t.html">resource</a>* res_new           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structresourcetype__t.html">resourcetype</a> *&nbsp;</td>
          <td class="paramname"> <em>restype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add a new resource to a resource type. 
<p>
After the first resource was added, any calls to <a class="el" href="data_8c.html#8c72b98be13cab05b381a8a78f6efabb" title="Define a new resource type.">restype_new()</a> have unspecified effects.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>restype</em>&nbsp;</td><td>Pointer to a resource type structure. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>Name of the resource to add. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Pointer to the resource struct on success and NULL on failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="18de03225d8f767f115c850d8d2a85fc"></a><!-- doxytag: member="data.c::res_new_matrix" ref="18de03225d8f767f115c850d8d2a85fc" args="(resourcetype *restype, int width, int height)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structresource__t.html">resource</a>* res_new_matrix           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structresourcetype__t.html">resourcetype</a> *&nbsp;</td>
          <td class="paramname"> <em>restype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>height</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds a matrix of resources to a resource type. 
<p>
This function adds <em>width</em> * <em>height</em> new resources to the specified resource type. New resources have names "x y", where <em>x</em> goes from 0 to <em>width</em> -1 and <em>y</em> goes from 0 to <em>height</em> -1. Resources are ordered first by <em>y</em> and then by <em>x</em>.<p>
For example:<p>
<div class="fragment"><pre class="fragment"> x=resid/height;
 y=resid%height;
</pre></div><p>
If there were no resources added to the resource type before the <a class="el" href="data_8c.html#18de03225d8f767f115c850d8d2a85fc" title="Adds a matrix of resources to a resource type.">res_new_matrix()</a> function was called, <em>x</em> now holds the x coordinate and <em>y</em> the y coordinate of the resource with <em>resid</em> resource ID in the matrix.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>restype</em>&nbsp;</td><td>Pointer to a resource type structure. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>width</em>&nbsp;</td><td>Width of the matrix. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>height</em>&nbsp;</td><td>Height of the matrix. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Pointer to the last resource struct in the matrix on success and NULL on failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="db3b01d97e46671cf4a05b1ac5590ce3"></a><!-- doxytag: member="data.c::res_set_conflict" ref="db3b01d97e46671cf4a05b1ac5590ce3" args="(resource *res1, resource *res2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void res_set_conflict           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structresource__t.html">resource</a> *&nbsp;</td>
          <td class="paramname"> <em>res1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structresource__t.html">resource</a> *&nbsp;</td>
          <td class="paramname"> <em>res2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set conflict between resource <em>res1</em> and resource <em>res2</em>. 
<p>
Resources must be of the same type. In most cases you must call this function twice:<p>
<div class="fragment"><pre class="fragment"> <a class="code" href="data_8c.html#db3b01d97e46671cf4a05b1ac5590ce3" title="Set conflict between resource res1 and resource res2.">res_set_conflict</a>(res1, res2);
 <a class="code" href="data_8c.html#db3b01d97e46671cf4a05b1ac5590ce3" title="Set conflict between resource res1 and resource res2.">res_set_conflict</a>(res2, res1);
</pre></div><p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>res1</em>&nbsp;</td><td>Pointer to the first resource struct. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>res2</em>&nbsp;</td><td>Pointer to the second resource struct. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="a86e740a213a28a01fcae6023a3f7c88"></a><!-- doxytag: member="data.c::restype_find" ref="a86e740a213a28a01fcae6023a3f7c88" args="(char *type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structresourcetype__t.html">resourcetype</a>* restype_find           </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>type</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Find a resource type by name. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>Name of the resource type to find. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Pointer to the resourcetype struct or NULL if this resource type was not found. </dd></dl>

</div>
</div><p>
<a class="anchor" name="bbfc9bd4c1cb4fc9e9c454823c0b011d"></a><!-- doxytag: member="data.c::restype_findid" ref="bbfc9bd4c1cb4fc9e9c454823c0b011d" args="(char *type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int restype_findid           </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>type</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Find a resource type (either variable or constant) by name and return a resource type ID. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>Name of the resource type to find. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Resource type ID or INT_MIN if this resource type was not found. </dd></dl>

</div>
</div><p>
<a class="anchor" name="8c72b98be13cab05b381a8a78f6efabb"></a><!-- doxytag: member="data.c::restype_new" ref="8c72b98be13cab05b381a8a78f6efabb" args="(int var, char *type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structresourcetype__t.html">resourcetype</a>* restype_new           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>type</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Define a new resource type. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>var</em>&nbsp;</td><td>1 if this is a variable resource type and 0 if this is a constant resource type. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>Name of this resource type (string is duplicated). </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Pointer to the resourcetype struct or NULL on error. </dd></dl>

</div>
</div><p>
<a class="anchor" name="8e0215f87e5f9bb04e91d481c10c9e76"></a><!-- doxytag: member="data.c::slist_new" ref="8e0215f87e5f9bb04e91d481c10c9e76" args="(slist **list, int vartype)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structslist__t.html">slist</a>* slist_new           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structslist__t.html">slist</a> **&nbsp;</td>
          <td class="paramname"> <em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>vartype</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Allocate a new slist struct in a linked list. 
<p>
Linked list is first searched for an identical slist struct. If such a structure is found, only a pointer to it is returned and the linked is is not changed. If no such structure exists, a new structure is allocated and inserted at the beginning of the linked list.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>list</em>&nbsp;</td><td>Pointer to the linked list. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vartype</em>&nbsp;</td><td>Variable resource type id. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Pointer to the new slist struct or NULL on error. </dd></dl>

</div>
</div><p>
<a class="anchor" name="ee56fd95809a035700e03c72671890c4"></a><!-- doxytag: member="data.c::slist_update" ref="ee56fd95809a035700e03c72671890c4" args="(slist *list, table *tab)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void slist_update           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structslist__t.html">slist</a> *&nbsp;</td>
          <td class="paramname"> <em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtable__t.html">table</a> *&nbsp;</td>
          <td class="paramname"> <em>tab</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Update slist with new data from a timetable. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>list</em>&nbsp;</td><td>Pointer to the slist structure to update. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tab</em>&nbsp;</td><td>Pointer to the table with the new data. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="36f9004d242d4b2e2fec8775a520aad8"></a><!-- doxytag: member="data.c::tuple_compare" ref="36f9004d242d4b2e2fec8775a520aad8" args="(int tupleid1, int tupleid2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int tuple_compare           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>tupleid1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>tupleid2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compare two events. 
<p>
Two events are considered equal (for example, they were defined as repeats of a single &lt;event&gt; tag), if their names are equal and if they have the same constant resources.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tupleid1</em>&nbsp;</td><td>Tuple ID of the first event. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tupleid2</em>&nbsp;</td><td>Tuple ID of the second event. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>1 if events are equal or 0 if the are not. </dd></dl>

</div>
</div><p>
<a class="anchor" name="44052420d49f2b5f148b523ed2f8c96d"></a><!-- doxytag: member="data.c::tuple_new" ref="44052420d49f2b5f148b523ed2f8c96d" args="(char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtupleinfo__t.html">tupleinfo</a>* tuple_new           </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add a new tuple. 
<p>
After the first tuple was added, any calls to <a class="el" href="data_8c.html#8c72b98be13cab05b381a8a78f6efabb" title="Define a new resource type.">restype_new()</a> and <a class="el" href="data_8c.html#ef5a6cb806d689cc5b76627abb5c2166" title="Add a new resource to a resource type.">res_new()</a> have unspecified effects.<p>
Tuples are independent by default.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>Name of the tuple (event). </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Pointer to the tupleinfo struct of the new tuple or NULL on error. </dd></dl>

</div>
</div><p>
<a class="anchor" name="bf094f2f8d7a6ad2fed40fd15580d5cb"></a><!-- doxytag: member="data.c::tuple_set" ref="bf094f2f8d7a6ad2fed40fd15580d5cb" args="(tupleinfo *tuple, resource *res)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tuple_set           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtupleinfo__t.html">tupleinfo</a> *&nbsp;</td>
          <td class="paramname"> <em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structresource__t.html">resource</a> *&nbsp;</td>
          <td class="paramname"> <em>res</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set a resource in a tuple. 
<p>
Note that only one resource of each type can be used in a tuple.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tuple</em>&nbsp;</td><td>Pointer to the tupleinfo struct of the tuple to change. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>res</em>&nbsp;</td><td>Pointer to the resource which is used by the tuple. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="6c1b05d7745473756e5fd19e695453ed"></a><!-- doxytag: member="data.c::tuplelist_add" ref="6c1b05d7745473756e5fd19e695453ed" args="(tuplelist *dest, int tupleid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int tuplelist_add           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtuplelist__t.html">tuplelist</a> *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>tupleid</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add a new tupleid to the tuplelist structure. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>Pointer to the tuplelist structure. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tupleid</em>&nbsp;</td><td>Tuple ID to add. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success and -1 on error. </dd></dl>

</div>
</div><p>
<a class="anchor" name="446a7351d03c08874dd0e9e2f9128103"></a><!-- doxytag: member="data.c::tuplelist_free" ref="446a7351d03c08874dd0e9e2f9128103" args="(tuplelist *dest)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tuplelist_free           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtuplelist__t.html">tuplelist</a> *&nbsp;</td>
          <td class="paramname"> <em>dest</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Frees a tuplelist structure. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>Pointer to the structure to free. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="c6fb99fb15e66709254a1a2dc077a02b"></a><!-- doxytag: member="data.c::tuplelist_new" ref="c6fb99fb15e66709254a1a2dc077a02b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtuplelist__t.html">tuplelist</a>* tuplelist_new           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Allocate a new empty tuplelist structure. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Pointer to the allocated structure or NULL on error. </dd></dl>

</div>
</div><p>
<hr size="1"><address style="text-align: right;"><small>Generated on Tue Jul 3 13:23:36 2007 for Tablix by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.2 </small></address>
</body>
</html>
